#!/bin/sh
#
# start_udev
#
# script to initialize /dev by using udev.
#
# Copyright (C) 2004 Greg Kroah-Hartman <greg@kroah.com>
#
# Released under the GPL v2 only.
#
# This needs to be run at the earliest possible point in the boot 
# process.
#
# Based on the udev init.d script
#
# Thanks go out to the Gentoo developers for proving 
# that this is possible to do.
#
# Yes, it's very verbose, feel free to turn off all of the echo calls,
# they were there to make me feel better that everything was working
# properly during development...
#
# don't use udev if sysfs is not mounted.
[ ! -d $sysfs_dir/class ] || exit 1
[ -r /proc/mounts ] || exit 1
[ -x /sbin/udev ] || exit 1
[ -f /etc/udev/udev.conf ] && . /etc/udev/udev.conf


. /etc/rc.d/init.d/functions

prog=udev
sysfs_dir=/sys
bin=/sbin/udev
udevd=/sbin/udevd
MAKEDEV="/sbin/MAKEDEV"

make_extra_nodes () {
	ln -snf /proc/self/fd $udev_root/fd
	ln -snf /proc/self/fd/0 $udev_root/stdin
	ln -snf /proc/self/fd/1 $udev_root/stdout
	ln -snf /proc/self/fd/2 $udev_root/stderr
	ln -snf /proc/kcore $udev_root/core

	[ -d $udev_root/pts ] || (mkdir $udev_root/pts;chmod 0755 $udev_root/pts)
	[ -d $udev_root/shm ] || (mkdir $udev_root/shm;chmod 0755 $udev_root/shm)

	if [ -x $MAKEDEV ]; then
		$MAKEDEV -x $( 
			for i in 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15; do
			    echo cpu/$i/microcode;
			done;
			for i in 1 2 3 4 5 6; do echo tty$i;done;
			for i in 0 1 2 3 4 5 6 7; do echo loop$i; done;
			for i in 0 1 2 3; do echo lp$i; echo par$i;done;
			echo net/tun ppp console null zero;
		);
		[ -a /dev/MAKEDEV ] || ln -s $MAKEDEV /dev/MAKEDEV;
		cp -a /etc/udev/devices/* /dev/ >/dev/null 2>&1 || :
	fi
}

# we cannot use /usr/bin/find here
find_d () {
        where=$1
        what=$2
        found=""
        for f in $where/*; do
                if [ -d "$f" -a ! -L "$f" ]; then
			if [ "$f" != "${f%%$what}" ];then 
			        # make sure we are at the path end
			        # we have no dirname and basename
				rest="${f#*$what}"
				[ "${rest##*/}" = "$rest" ] && found="$found $f"
			fi
                        found="$found $(find_d $f $what)"
                fi
        done
        echo "$found"
}

# we cannot use /usr/bin/find here
find_f () {
	where=$1
	what=$2
	found=""
	for f in $where/*; do
		if [ -d "$f" -a ! -L "$f" ]; then
			found="$found $(find_f $f $what)"
		elif [ -e "$f" ]; then 
			[ "$f" != "${f%$what}" ] && found="$found $f"
		fi
	done
	echo "$found"
}

# call hotplug with the scsi devices
scsi_replay () {
        HOTPLUG=$(cat /proc/sys/kernel/hotplug)
        [ -z "$HOTPLUG" ] && return 1

        scsi_hosts=$(find_d /sys/devices host\*)
        SEQNUM=1

        for host in $scsi_hosts; do
                [ -d $host ] || continue
                devs=$(find_f $host type)
                for dev in $devs;do
                        [ -f $dev ] || continue
                        export SEQNUM
                        DEVPATH=${dev%/type}
                        DEVPATH=${DEVPATH#/sys}
                        export DEVPATH
                        export ACTION=add
                        $HOTPLUG scsi_device
                        SEQNUM=$(($SEQNUM + 1)
                        $HOTPLUG scsi 
                        SEQNUM=$(($SEQNUM + 1)
                done
        done
        return 0
}

export ACTION=add
export UDEV_NO_SLEEP=1
prog=udev
ret=0
nls "Starting udev"
# propagate $udev_root from /sys
grep -q "none ${udev_root%/} " /proc/mounts || { 
	mount -n -o mode=0755 -t tmpfs none "$udev_root"
	ret=$(($ret + $?))
}
make_extra_nodes
scsi_replay >/dev/null 2>&1
ret=$(($ret + $?))
rm -f $udev_root/.udev.tdb
/sbin/udevstart 
ret=$(($ret + $?))
[ $ret -eq 0 ] && ok || fail
exit 0
